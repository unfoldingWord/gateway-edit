

<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      hooks/useLexicon.js - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">

  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
  

  <!-- start Mixpanel -->
  <script type="text/javascript">(function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+"=([^&]*)")))?l[1]:null};g&&c(g,"state")&&(i=JSON.parse(decodeURIComponent(c(g,"state"))),"mpeditor"===i.action&&(b.sessionStorage.setItem("_mpcehash",g),history.replaceState(i.desiredHash||"",e.title,j.pathname+j.search)))}catch(m){}var k,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(".");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,
  0)))}}var d=a;"undefined"!==typeof f?d=a[f]=[]:f="mixpanel";d.people=d.people||[];d.toString=function(b){var a="mixpanel";"mixpanel"!==f&&(a+="."+f);b||(a+=" (stub)");return a};d.people.toString=function(){return d.toString(1)+".people (stub)"};k="disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");
  for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)}})(document,window.mixpanel||[]);
  mixpanel.init("1919205b2da72e4da3b9b6639b444d59");</script>
  <!-- end Mixpanel -->
</head>

<body>
  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <div class="top-nav-wrapper">
    <ul>
      <li >
        <a href="index.html">
          
            <svg fill="#6D6D6D" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
              <path d="M0 0h24v24H0z" fill="none"/>
            </svg>
          
          
        </a>
      </li>

      
      <li>
        <div class="search-wrapper">
          <svg fill="#6D6D6D" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
            <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
            <path d="M0 0h24v24H0z" fill="none"/>

          </svg>
          <input type="text" placeholder="Search" class="search-input">
        </div>
      </li>
      

    </ul>
  </div>

  <nav>
    <h3 class="reference-title">
      translationCore
    </h3>

    <h3>Classes</h3><ul><li id="Alert-nav"><a href="Alert.html">Alert</a></li></ul><h3 id="global-nav">Global</h3><ul><li><a href="global.html#BIBLE_BOOKS">BIBLE_BOOKS</a></li><li><a href="global.html#addNetworkDisconnectError">addNetworkDisconnectError</a></li><li><a href="global.html#doFetch">doFetch</a></li><li><a href="global.html#doLogin">doLogin</a></li><li><a href="global.html#extractGlossesFromRepoZip">extractGlossesFromRepoZip</a></li><li><a href="global.html#findBestLexicon">findBestLexicon</a></li><li><a href="global.html#getErrorMessageForResourceLink">getErrorMessageForResourceLink</a></li><li><a href="global.html#getLatestBibleRepo">getLatestBibleRepo</a></li><li><a href="global.html#getLexiconData">getLexiconData</a></li><li><a href="global.html#getLocalStorageItem">getLocalStorageItem</a></li><li><a href="global.html#getNetworkError">getNetworkError</a></li><li><a href="global.html#getRepoUrl">getRepoUrl</a></li><li><a href="global.html#getResourceMessage">getResourceMessage</a></li><li><a href="global.html#getServerFault">getServerFault</a></li><li><a href="global.html#getUserKey">getUserKey</a></li><li><a href="global.html#goToPage">goToPage</a></li><li><a href="global.html#gotoFeedback">gotoFeedback</a></li><li><a href="global.html#isServerDisconnected">isServerDisconnected</a></li><li><a href="global.html#onNetworkActionButton">onNetworkActionButton</a></li><li><a href="global.html#processNetworkError">processNetworkError</a></li><li><a href="global.html#readUserItem">readUserItem</a></li><li><a href="global.html#reloadApp">reloadApp</a></li><li><a href="global.html#setLocalStorageValue">setLocalStorageValue</a></li><li><a href="global.html#setUserItem">setUserItem</a></li><li><a href="global.html#translate">translate</a></li><li><a href="global.html#unAuthenticated">unAuthenticated</a></li><li><a href="global.html#useUserLocalStorage">useUserLocalStorage</a></li><li><a href="global.html#useWindowEvent">useWindowEvent</a></li></ul>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        hooks/useLexicon.js
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>import { useEffect, useState } from 'react'
import * as isEqual from 'deep-equal'
import { getFilesFromRepoZip, useRepository } from 'gitea-react-toolkit'
import { core } from 'scripture-resources-rcl'
import { isNT } from '@common/BooksOfTheBible'
import { delay } from '@utils/resources'
import {
  extractGlossesFromRepoZip,
  fetchFromGlossesStore,
  getOriginalLanguageStr,
  findBestLexicon,
  saveToGlossesStore,
} from '@utils/lexiconHelpers'

export default function useLexicon({
  bookId,
  languageId,
  server,
}) {
  const [greekError, setGreekError] = useState(null)
  const [hebrewError, setHebrewError] = useState(null)
  const [repository, setRepository] = useState(null)
  const [lexCacheInit, setLexCacheInit] = useState(false)
  const [lexiconGlosses, setLexiconGlosses] = useState(null)
  const [fetchingLexicon, setFetchingLexicon] = useState(false)
  const [fetchingGlosses, setFetchingGlosses] = useState(false)
  const [greekLexConfig, setGreekLexConfig] = useState(null)
  const [hebrewLexConfig, setHebrewLexConfig] = useState(null)
  const [strongsNumbersInVerse, setStrongsNumbersInVerse] = useState(null)

  const isNT_ = isNT(bookId)

  const origlangLexConfig = getOriginalLanguageConfig()
  const lexRepoName = origlangLexConfig ? `${origlangLexConfig.languageId}_${origlangLexConfig.resourceId}` : null
  const lexRepoFullName = origlangLexConfig ? `${origlangLexConfig.owner}/${lexRepoName}` : null
  const lexiconProps = useRepository({
    full_name: lexRepoFullName,
    branch: origlangLexConfig?.ref,
    config: origlangLexConfig,
    repository,
    onRepository,
  })

  function getOriginalLanguageConfig() {
    const origlangLexConfig = isNT_ ? greekLexConfig : hebrewLexConfig
    return origlangLexConfig
  }

  function setOrigLangError(error, isNT = isNT_) {
    if (isNT) {
      setGreekError(error)
    } else {
      setHebrewError(error)
    }
  }

  function getOrigLangError() {
    if (isNT_) {
      return greekError
    } else {
      return hebrewError
    }
  }

  useEffect(() => {
    // console.log(`useLexicon: bible ${bookId} changed testament ${isNT_}`)
    setRepository(null) // clear lexicon repo so it's reloaded after testament change
    setStrongsNumbersInVerse(null)
    setLexiconGlosses(null)
    setLexCacheInit(false)
  }, [isNT_])

  /**
   * callback function for when useRepository has loaded repo
   * @param repo
   */
  function onRepository(repo) {
    if ( repo?.branch &amp;&amp; (repo?.html_url !== repository?.html_url)) {
      // console.log(`useLexicon.onRepository(): url changed to ${repo?.html_url} from ${repository?.html_url}`, repo)
      setRepository(repo)
    }
  }

  /**
   * convert status/error message to gloss format
   * @param message
   * @return {{brief, long}}
   */
  function messageToGloss(message) {
    return {
      brief: message,
      long: message,
    }
  }

  function getReasonForLexiconFailure(defaultMessage, entryId) {
    const error = getOrigLangError()
    let message = defaultMessage

    if (error) {
      message = `### ERROR: ${error}`
    } else if (!getOriginalLanguageConfig()) {
      message = `Not ready - searching for lexicon`
    } else if (!repository) {
      message = `Not ready - loading lexicon repo data`
    } else if (fetchingLexicon) {
      message = `Not ready - fetching lexicon repo`
    } else if (!lexCacheInit || fetchingGlosses) {
      message = `Not ready - initializing glosses`
    }
    // console.log(`useLexicon.getLexiconData: gloss not loaded for ${entryId}`, message)
    return message
  }

  /**
   * external function to load lexicon from cached lexicon
   * @param {string} lexiconId - lexicon to search (ugl or uhl)
   * @param {string|number} entryId - numerical part of the strongs number (e.g. '00005')
   * @return {*}
   */
  function getLexiconData(lexiconId, entryId) {
    let gloss = null

    if (lexiconGlosses &amp;&amp; entryId) {
      gloss = lexiconGlosses[entryId.toString()]

      if (!gloss) { // show reason we can't find gloss
        const defaultMessage = `### ERROR: Gloss not found`
        const message = getReasonForLexiconFailure(defaultMessage, entryId)
        gloss = messageToGloss(message)
      }
    } else { // show error or reason glosses are not loaded
      const defaultMessage = `Not ready - glosses not yet available`
      // console.log(`useLexicon.getLexiconData - lexiconId ${lexiconId}, lexiconGlosses length = ${lexiconGlosses?.length}`)
      const message = getReasonForLexiconFailure(defaultMessage, entryId)
      gloss = messageToGloss(message)
    }
    return { [lexiconId]: { [entryId]: gloss } }
  }

  /**
   * save updated lexicon words in state and in indexDB
   * @param newLexiconGlosses
   * @return {Promise&lt;void>}
   */
  async function updateLexiconGlosses(newLexiconGlosses) {
    // console.log(`useLexicon.updateLexiconGlosses -`, newLexiconGlosses)
    setLexiconGlosses(newLexiconGlosses)
    await saveToGlossesStore(getGlossesCachePath(), newLexiconGlosses)
  }

  /**
   * called to prefetch all the lexicon data for a verse
   * @param {object[]} verseObjects
   * @param {string} languageId
   * @return {Promise}
   */
  async function fetchGlossesForVerse(verseObjects, languageId) {
    if (origlangLexConfig?.origLangId !== languageId) {
      return
    }

    if (origlangLexConfig &amp;&amp; verseObjects?.length &amp;&amp; !fetchingGlosses) {
      // console.log(`useLexicon.fetchGlossesForVerse - language ${languageId}, ${verseObjects?.length} verseObjects`)
      const wordObjects = core.getWordObjects(verseObjects)

      if (wordObjects?.length) {
        const strongs = core.getStrongsList(wordObjects)

        // check if already prefetching this list
        if (strongs?.length &amp;&amp; !isEqual(strongs, strongsNumbersInVerse)) {
          // console.log(`useLexicon.fetchGlossesForVerse - found strongs numbers in verses`, strongs)
          setStrongsNumbersInVerse(strongs)

          if (lexiconGlosses &amp;&amp; Object.keys(lexiconGlosses).length) {
            // console.log(`useLexicon.fetchGlossesForVerse - loading strongs numbers`)
            await fetchGlossesForStrongsNumbers(strongs)
          }
        } else if (!strongs?.length) {
          console.log(`useLexicon.fetchGlossesForVerse - no strongs numbers found`)
        }
      }
    }
  }

  async function getFilesFromCachedLexicon() {
    const files = await getFilesFromRepoZip({
      owner: origlangLexConfig.owner,
      repo: lexRepoName,
      branch: origlangLexConfig.ref,
      config: { server: origlangLexConfig.server },
    })
    return files
  }

  /**
   * used to preload glosses for a list of strongs numbers (useful to do as verse is loaded)
   * @param {array} strongs
   * @return {Promise&lt;void>}
   */
  async function fetchGlossesForStrongsNumbers(strongs) {
    if (strongs?.length &amp;&amp; !fetchingGlosses &amp;&amp; origlangLexConfig) {
      // console.log(`useLexicon.fetchGlossesForStrongsNumber: extracting strongs list length ${strongs.length}`, strongs)
      setFetchingGlosses(true)
      let newLexiconWords = (await fetchFromGlossesStore(getGlossesCachePath())) || {}
      // console.log(`useLexicon.fetchGlossesForStrongsNumber: already extracted word length ${Object.keys(newLexiconWords).length}`, newLexiconWords)
      const files = await getFilesFromCachedLexicon()
      let modified = await extractGlossesFromRepoZip(lexRepoName, origlangLexConfig, strongs, newLexiconWords, files)

      if (modified) {
        await updateLexiconGlosses(newLexiconWords)
        // console.log('useLexicon.fetchGlossesForStrongsNumbers: lexicon words updated, length', Object.keys(newLexiconWords).length)
      } else {
        setLexiconGlosses(newLexiconWords)
      }

      // console.log('useLexicon.fetchGlossesForStrongsNumbers: new word list length', strongs?.length)
      setFetchingGlosses(false)
    }
  }

  async function unzipFileFromCachedLexicon(filename) {
    const filePath = `${origlangLexConfig.lexiconPath}/${filename}`
    const file = await lexiconProps?.actions?.fileFromZip(filePath)
    // console.log(`initLexicon.unzipFileFromCachedLexicon`, file)
    return file
  }

  async function getGlossFromCachedLexicon(strongs) {
    const filename = `${strongs}.json`
    const file = await unzipFileFromCachedLexicon(filename)
    // console.log(`initLexicon.getGlossFromCachedLexicon`, !!file)
    return file
  }

  async function isLexiconRepoCached() {
    const file = await getGlossFromCachedLexicon(1)
    // console.log(`initLexicon.isLexiconRepoCached`, !!file)
    return !!file
  }

  /**
   * find best fit lexicon repo for given languageId, testament, and owner
   * @param {boolean} isNT
   * @return {Promise&lt;void>}
   */
  async function initLexiconForTestament(isNT) {
    const LexOwner = 'test_org'
    const branch = 'master'
    const setLexicon = isNT ? setGreekLexConfig : setHebrewLexConfig
    const lexConfig = await findBestLexicon(languageId, server, LexOwner, branch, setLexicon, isNT)

    if (!lexConfig) {
      const OrigLang = getOriginalLanguageStr(isNT)
      setOrigLangError(`initLexicon() - failure to find ${OrigLang} Lexicon`, isNT)
    }
  }

  useEffect(() => {
    /**
     * find best fit lexicon repos for both testaments of given languageId and owner
     * @return {Promise&lt;void>}
     */
    async function getLexicons() {
      if (languageId &amp;&amp; server) {
        await delay(2000) // wait for other resources to load
        await initLexiconForTestament(isNT_) // find lexicon for current testament
        await delay(1000) // wait for other resources to load
        await initLexiconForTestament(!isNT_) // find lexicon for other testament
      }
    }

    getLexicons()
  }, [languageId, server])

  function getGlossesCachePath() {
    const lexiconCachePath = `${origlangLexConfig.server}/${origlangLexConfig.owner}/${origlangLexConfig.languageId}_${origlangLexConfig.resourceId}/${origlangLexConfig.ref}`
    return lexiconCachePath
  }

  useEffect(() => {
    /**
     * make sure we have downloaded lexicon zip
     * @return {Promise&lt;void>}
     */
    const loadLexiconDataForRepo = async () => {
      // console.log(`useLexicon.loadLexiconDataForRepo: hook called`, { fetchingLexicon, repository, storeZip: !!lexiconProps?.actions?.storeZip})

      if (!fetchingLexicon &amp;&amp; repository &amp;&amp; lexiconProps?.actions?.storeZip) {
        try {
          // console.log(`useLexicon.loadLexiconDataForRepo: fetching glosses`)
          setFetchingLexicon(true)
          let lexiconWords = await fetchFromGlossesStore(getGlossesCachePath())

          if (!lexiconWords) {
            lexiconWords = {}
          } else {
            // console.log(`useLexicon.loadLexiconDataForRepo: ${getGlossesCachePath()} cached lexicon words length`, Object.keys(lexiconWords).length)
          }

          let lexiconRepoCached = await isLexiconRepoCached()

          if (lexiconRepoCached) {
            // console.log(`useLexicon.loadLexiconDataForRepo: lexicon zip already loaded`)
          } else {
            // console.log(`useLexicon.loadLexiconDataForRepo: loading from indexDB`)
            // fetch repo zip file and store in index DB
            await lexiconProps?.actions?.storeZip()
            // verify that zip file is loaded
            lexiconRepoCached = await isLexiconRepoCached()
          }

          if (lexiconRepoCached) {
            await updateLexiconGlosses(lexiconWords)
            // console.log(`useLexicon.loadLexiconDataForRepo: lexicon loaded and ready`)
            setLexCacheInit(true)
            setOrigLangError(null)
          } else {
            const originalLang = getOriginalLanguageStr(isNT_)
            console.warn(`useLexicon.loadLexiconDataForRepo: could not load ${originalLang} lexicon repo zip: ${getGlossesCachePath()}`)
            setOrigLangError(`Could not load ${originalLang} lexicon repo zip: ${getGlossesCachePath()}`)
          }
        } catch (e) {
          console.warn(`useLexicon.loadLexiconDataForRepo: exception thrown`, e)
        }

        setFetchingLexicon(false)
      }
    }

    loadLexiconDataForRepo()
  }, [repository])

  useEffect(() => {
    const updateGlossesForLatestVerse = async () => {
      if (lexCacheInit) {
        // console.log(`useLexicon - init lexCacheInit now`, { lexCacheInit, strongsNumbersInVerse })

        if (strongsNumbersInVerse) { // get Lexicons for current verse
          // console.log(`useLexicon - init calling fetchGlossesForStrongsNumbers()`)
          await fetchGlossesForStrongsNumbers(strongsNumbersInVerse)
        }
      }
    }

    updateGlossesForLatestVerse()
  }, [lexCacheInit, strongsNumbersInVerse])


  return {
    state: {
      repository,
      greekLexConfig,
      hebrewLexConfig,
      origlangLexConfig,
    },
    actions: {
      fetchGlossesForStrongsNumbers,
      fetchGlossesForVerse,
      getLexiconData,
      setGreekLexConfig,
      setHebrewLexConfig,
    },
  }
}
</code></pre>
  </article>
</section>

    


  </div>

  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.2</a>
  </footer>

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>

  
  <script>
    $(function () {
      window.docsearch({
        apiKey: 'f12d46ccb502a9c723d200abe3e3befd',
        indexName: 'translation_core',
        inputSelector: '.search-input',
        debug: false, // Set debug to true if you want to inspect the dropdown
        algoliaOptions: {
          hitsPerPage: 7
        }
      });
    });
  </script>
  

</body>
</html>
